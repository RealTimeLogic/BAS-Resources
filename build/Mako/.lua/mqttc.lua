local a=string.format;local b,c,d,e,f,g,h=ba.bytearray.create,ba.bytearray.copy,ba.bytearray.h2n,ba.bytearray.n2h,ba.bytearray.size,ba.bytearray.setsize,ba.bytearray.tostring;local i,j=string.byte,string.sub;local k,l=table.insert,table.sort;local m;local n=0x01<<4;local o=0x02<<4;local p=0x03<<4;local q=0x04<<4;local r=0x05<<4;local s=0x06<<4;local t=0x07<<4;local u=0x08<<4;local v=0x09<<4;local w=0x0a<<4;local x=0x0b<<4;local y=0x0c<<4;local z=0x0d<<4;local A=0x0e<<4;local function B(C,D,E)return a("bad argument #%d (%s expected, got %s)",C,D,type(E))end;local function F(C,D,E,G)if D~=type(E)then error(B(C,D,E),G or 2)end end;local function H(I,J,K,G)if type(K)==J then return end;error(a("%s: expected %s, got %s",I,J,type(K)),G or 3)end;local function L(M)local N={}if M then for O,P in pairs(M)do N[O]=P end end;return N end;local function Q(R,S)for O,P in pairs(S)do R[O]=P end end;local function T(self)local U=self.packetId;U=U+1;self.packetId=U<0xFFFF and U or 1;return self.packetId end;local function V(self)local U=self.subscriptionId;U=U+1;self.subscriptionId=U<268435455 and U or 1;return self.subscriptionId end;local function W(self,X,Y)local Z=self.recQosCounter;self.recQosCounter=Z+1;self.recQosQT[X]={bta=Y,counter=Z}end;local function _(self,X,Y)local Z=self.sndQosCounter;self.sndQosCounter=Z+1;self.sndQosQT[X]={bta=Y,counter=Z}end;local function a0(a1)local a2={}for O,P in pairs(a1)do k(a2,P)end;l(a2,function(a3,a4)return a3.counter<a4.counter end)return a2 end;local function a5(Y,a6,a7)if Y then local a8;while true do a8=a7%0x80;a7=a7//0x80;if a7==0 then break end;Y[a6]=a8|0x80;a6=a6+1 end;Y[a6]=a8;return a6+1 end;while true do a7=a7//0x80;if a7==0 then break end;a6=a6+1 end;return a6+1 end;local function a9(Y,a6,aa)if Y then Y[a6]=aa end;return a6+1 end;local function ab(Y,a6,ac)if Y then d(Y,a6,2,ac)end;return a6+2 end;local function ad(Y,a6,ac)if Y then d(Y,a6,4,ac)end;return a6+4 end;local function ae(Y,a6,af)local a7=#af;if Y then d(Y,a6,2,a7)Y[a6+2]=af end;return a6+2+a7 end;local ag=ae;local function ah(packetLen)return b(1+a5(nil,0,packetLen)+packetLen)end;local ai={payloadformatindicator={1,a9},messageexpiryinterval={2,ad},contenttype={3,ae},responsetopic={8,ae},correlationdata={9,ag},zz_subid={11,a5},sessionexpiryinterval={17,ad},requestprobleminformation={23,a9},willdelayinterval={24,ad},requestresponseinformation={25,a9},["$reason"]={31,ae},maximumpacketsize={39,ad}}local function aj(Y,a6,I,K)local ak=ai[I]if ak then a6=a9(Y,a6,ak[1])return ak[2](Y,a6,K)end;a6=a9(Y,a6,38)a6=ae(Y,a6,I)return ae(Y,a6,K)end;local function ai(Y,a6,al)if not al then return a6 end;for I,K in pairs(al)do a6=aj(Y,a6,I,K)end;return a6 end;local function am(an,G)an.qos=an.qos or 0;H("opt.will","table",an,G)H("opt.will.topic","string",an.topic,G)if an.prop then H("opt.will.prop","table",an.prop,G)end;H("opt.will.payload","string",an.payload,G)end;local function ao(self,ap)local aq=self.opt;local ar=self.prop;local an;if not ar.sessionexpiryinterval or ar.sessionexpiryinterval==0 then ap=true end;local as;local a6=ae(nil,10,aq.clientidentifier)local at=ai(nil,0,ar)a6=a5(nil,a6+at,at)if aq.will then an=aq.will;am(an,5)as=ai(nil,0,an.prop)a6=a5(nil,a6+as,as)a6=ae(nil,a6,an.topic)a6=ae(nil,a6,an.payload or"")end;if aq.username then H("opt.username","string",aq.username,4)a6=ae(nil,a6,aq.username)end;if aq.password then H("opt.password","string",aq.password,4)a6=ae(nil,a6,aq.password)end;local packetLen=a6;local Y=ah(packetLen)a6=a9(Y,1,n)a6=a5(Y,a6,packetLen)a6=ae(Y,a6,"MQTT")a6=a9(Y,a6,5)local au=aq.username and 0x80 or 0|aq.password and 0x40 or 0|ap and 0x02 or 0;if an then au=au|an.retain and 0x20 or 0|(an.qos<<2)|0x04 end;a6=a9(Y,a6,au)a6=ab(Y,a6,aq.keepalive)a6=a5(Y,a6,at)a6=ai(Y,a6,ar)a6=ae(Y,a6,aq.clientidentifier)if an then a6=a5(Y,a6,as)a6=ai(Y,a6,an.prop)a6=ae(Y,a6,an.topic)a6=ag(Y,a6,an.payload)end;if aq.username then a6=ae(Y,a6,aq.username)end;if aq.password then a6=ae(Y,a6,aq.password)end;if a6-1~=ba.bytearray.size(Y)then error(a("ix~=bta size: %d ~= %d",a6-1,ba.bytearray.size(Y)))end;return Y end;local function av(Y,a6)local aw,a7=1,0;repeat local a8=Y[a6]a7=a7+a8&0x7F*aw;aw=aw*0x80;a6=a6+1 until a8<0x80;return a7,a6 end;local function ax(Y,a6)return Y[a6],a6+1 end;local function ay(Y,a6)return e(Y,a6,2),a6+2 end;local function az(Y,a6)return e(Y,a6,4),a6+4 end;local function aA(Y,a6,af)local a7=e(Y,a6,2)a6=a6+2;local aB=a6+a7;return h(Y,a6,aB-1),aB end;local aC=aA;local aD={[1]={"payloadformatindicator",ax},[2]={"messageexpiryinterval",az},[3]={"contenttype",aA},[8]={"responsetopic",aA},[9]={"correlationdata",aC},[11]={"subscriptionidentifier",av},[17]={"sessionexpiryinterval",az},[18]={"assignedclientidentifier",aA},[19]={"serverkeepalive",ay},[21]={"authenticationmethod",aA},[22]={"authenticationdata",aC},[26]={"responseinformation",aA},[28]={"serverreference",aA},[31]={"reasonstring",aA},[33]={"receivemaximum",ay},[34]={"topicaliasmaximum",ay},[35]={"topicalias",ay},[36]={"maximumqos",ax},[37]={"retainavailable",ax},[39]={"maximumpacketsize",az},[40]={"wildcardsubscriptionavailable",ax},[41]={"subscriptionidentifieravailable",ax},[42]={"sharedsubscriptionavailable",ax}}local function aE(Y,a6,al)local aF=Y[a6]a6=a6+1;local ak=aD[aF]if ak then al[ak[1]],a6=ak[2](Y,a6)elseif 38==aF then local aG;aG,a6=aA(Y,a6)al[aG],a6=aA(Y,a6)else return nil end;return a6 end;local function aH(Y,at,a6)local al={}while at>0 do local aI=a6;a6=aE(Y,a6,al)if not a6 then return nil,1 end;at=at-(a6-aI)end;if at==0 then return al,a6 end;return nil,a6 end;local function aJ(self)local aK=self.sock;local aL,aM,aN;if self.recOverflowData then aL=self.recOverflowData;self.recOverflowData=nil else aL=""end;local aw,a7,a6=1,0,1;repeat a6=a6+1;while#aL<a6 do aM,aN=aK:read()if not aM then return nil,aN end;aL=aL..aM end;local a8=i(aL,a6)a7=a7+a8&0x7F*aw;aw=aw*0x80 until a8<0x80;local aO=i(aL,1)local Y;if a7>0 then Y=b(a7)local aP=c(Y,1,aL,a6+1,-a6-1)local aQ=#aL-a6;while aQ<a7 do aL,aN=aK:read()if not aL then return nil,aN end;aP=c(Y,1+aQ,aL)aQ=aQ+#aL end;if aP>0 then self.recOverflowData=j(aL,#aL-aP+1)end end;return aO,Y end;local function aR(aK,self)local aS=self.sndQT;while true do local aT=self.sndQTail;if self.sndQHead==aT then aK:disable()end;if not self.connected then return end;assert(self.sndQHead~=aT)local Y=aS[aT]assert(Y)if not self.sock:write(Y)then self.connected=false;return end;aS[aT]=nil;self.sndQTail=aT+1;self.sndQElems=self.sndQElems-1 end end;local function aU(self,Y)if self.sndQHead==self.sndQTail and self.connected then local aV,aW=self.sock:write(Y)if aV then return end;if"string"==type(aW)then self.lasterror={etype="sock",status=aW}self.connected=false end end;local aX=self.sndQHead;assert(nil==self.sndQT[aX])self.sndQT[aX]=Y;self.sndQHead=aX+1;self.sndQElems=self.sndQElems+1;if self.connected then self.sndCosock:enable()end end;local function aY(self)local aZ=self.pingCounter;aZ=aZ+1;if aZ==2 then local Y=ah(0)Y[1]=y;Y[2]=0;aU(self,Y)elseif aZ>2 then self.lasterror={etype="mqtt",status="pingtimeout"}self.connected=false;self.sock:close()end;self.pingCounter=aZ end;local function a_(self,aO,X,b0)local Y=ah(4)Y[1]=aO;Y[2]=4;d(Y,3,2,X)Y[5]=b0;Y[6]=0;aU(self,Y)return Y end;local function b1(Y)local b0=f(Y)==2 and 0 or Y[3]return e(Y,1,2),b0 end;local function b2(self,Y,aO)local al,b3;local b4,a6=aA(Y,1)if b4 then local b5=aO>>1&3;if b5>0 then b3,a6=ay(Y,a6)end;al,a6=aH(Y,av(Y,a6))if al then local a1=self.recQosQT;if not a1[b3]then local b6=self.onpubT[al.subscriptionidentifier]or self.onpub;g(Y,a6)b6(b4,self.recbta and Y or h(Y),al,aO)end;if b5==0 then return true end;Y=a_(self,b5==1 and q or r,b3,0)if b5==2 then W(self,b3,Y)end;return true end end;return nil,"mqtt","protocolerror"end;local function b7(self,Y)local b3,b0=b1(Y)self.sndQosQT[b3]=nil;return true end;local function b8(self,Y)local b9=self.sndQosQT;local b3,b0=b1(Y)if b0<0x80 then b0=b9[b3]and 0 or 146;Y=a_(self,s|2,b3,b0)if 0==b0 then _(self,b3,Y)return true end end;b9[b3]=nil;return true end;local function bb(self,Y)local b3,b0=b1(Y)self.recQosQT[b3]=nil;a_(self,t,b3,b0)return true end;local function bc(self,Y)local b3,b0=b1(Y)self.sndQosQT[b3]=nil;return true end;local function bd(self,b4)local be=self.topicT[b4]if be then self.topicT[b4]=nil;self.onpubT[be]=nil end end;local function bf(self,Y)local X,a6=ay(Y,1)local al;al,a6=aH(Y,av(Y,a6))if not al then return nil,"mqtt","protocolerror"end;local b0=Y[a6]local M=self.subackQT[X]self.sndQosQT[X]=nil;if M then self.subackQT[X]=nil;bd(self,M.topic)if M.onsuback then M.onsuback(M.topic,b0,al)end;if b0<0x80 then if M.onpub then self.onpubT[M.subid]=M.onpub;self.topicT[M.topic]=M.subid end end else end;return true end;local function bg(self,Y)local X,a6=ay(Y,1)local al;al,a6=aH(Y,av(Y,a6))if not al then return nil,"mqtt","protocolerror"end;local b0=Y[a6]local M=self.subackQT[X]self.sndQosQT[X]=nil;if M then self.subackQT[X]=nil;bd(self,M.topic)if M.onunsubscribe then M.onunsubscribe(M.topic,b0,al)end else end;return true end;local function bh(self,Y)self.pingCounter=0;return true end;local function bi(self,Y)local al,a6=aH(Y,av(Y,2))if al then local bj={reasoncode=Y[1],properties=al}return nil,"mqtt","disconnect",bj end;return nil,"mqtt","protocolerror"end;local bk={[p]=b2,[q]=b7,[r]=b8,[s]=bb,[t]=bc,[v]=bf,[x]=bg,[z]=bh,[A]=bi}local function bl(self,bm)if bm then self.savedT={recQosQT=self.recQosQT,sndQosQT=self.sndQosQT,subackQT=self.subackQT,onpubT=self.onpubT,topicT=self.topicT}end;self.recQosQT,self.sndQosQT,self.subackQT,self.onpubT,self.topicT={},{},{},{},{}end;local function bn(self,bo)if bo then local M=self.savedT;Q(self.recQosQT,M.recQosQT)Q(self.sndQosQT,M.sndQosQT)Q(self.subackQT,M.subackQT)Q(self.onpubT,M.onpubT)Q(self.topicT,M.topicT)local b9=self.recQosQT;if next(b9)then for bp,M in pairs(a0(b9))do aU(self,M.bta)end end;b9=self.sndQosQT;if next(b9)then for bp,M in pairs(a0(b9))do local Y=M.bta;local aO=Y[1]if aO&0xF0==p then Y[1]=aO|0x08 end;aU(self,Y)end end end;self.savedT=nil end;local function bq(self,br,bs)local bt=self.onstatus(br,bs)if bt then self.reconTimeout="number"==type(bt)and bt end;return bt end;local function bu(self)local aV,br,aW,bv;while self.connected do local aO,Y=aJ(self)if not aO then aW=Y;break end;local bw=bk[aO&0xF0]if not bw then br,aW="mqtt","protocolerror"break end;aV,br,aW,bv=bw(self,Y,aO)if not aV then break end;br,aW,bv=nil,nil,nil end;local bx=self.lasterror;self.connected,self.lasterror,self.recOverflowData=false,nil,nil;if self.pingTimer then self.pingTimer:cancel()end;bl(self,true)if not br then local bx=self.lasterror;if bx then br,aW=bx.etype,bx.status else aW=aW or""br="sock"end end;if not self.disconnected and bq(self,br,aW,bv)then self.connectTime=nil;if"sysshutdown"~=aW then m(self,ao(self,false))end end end;local function by(aK,self,bz)local bA;self.sock=aK;aK:write(bz)local aO,Y=aJ(self)if aO then if aO&0xF0==o then local bB=aH(Y,av(Y,3))if bB then local bo=Y[1]&1==1 and true or false;local b0=Y[2]bA=self.onstatus("mqtt","connect",{sessionpresent=bo,reasoncode=b0,properties=bB})if b0==0 and bA then local aq=self.opt;if bB.serverkeepalive and bB.serverkeepalive~=aq.keepalive then aq.keepalive=bB.serverkeepalive end;if aq.keepalive~=0 then self.pingCounter=0;self.pingTimer=ba.timer(function()aY(self)return true end)self.pingTimer:set(aq.keepalive*1000//2)end;local ar=self.prop;if bB.sessionexpiryinterval and bB.sessionexpiryinterval~=ar.sessionexpiryinterval then ar.sessionexpiryinterval=bB.sessionexpiryinterval end;self.connected=true;bn(self,bo)self.sndCosock=ba.socket.event(aR,self)bu(self)return end end end;if bA==nil then bA=bq(self,"mqtt","protocolerror")end else bA=bq(self,"sock",Y)end;if bA then m(self,bz,false)end end;local function bC(bD,self,bz)self.connectTime=ba.clock()//1000;local aK,aN=self.connect(self,self.opt)if self.disconnected then if aK then aK:close()end;return end;self.sock=aK;if not aK then if bq(self,"sock",aN)then m(self,bz,true)end else by(aK,self,bz)end end;local bE={}bE.__index=bE;function bE:publish(b4,aM,aq,ar)local aq=aq or{}local b5=aq.qos or 0;b5=b5&3<<1;local bF=aq.retain and 1 or 0;local at=ai(nil,0,ar)local a6=a5(nil,(b5>0 and 3 or 1)+at,at)a6=ae(nil,a6,b4)packetLen=a6+#aM-1;local Y=ah(packetLen)Y[1]=p|b5|bF;a6=a5(Y,2,packetLen)a6=ae(Y,a6,b4)if b5>0 then local X=T(self)a6=ab(Y,a6,X)_(self,X,Y)end;a6=a5(Y,a6,at)a6=ai(Y,a6,ar)Y[a6]=aM;aU(self,Y)return self.connected end;local function bG(self,b4,bH,ar,bI)local X=T(self)local a6=bI and 2 or 1;local at=ai(nil,0,ar)local a6=a5(nil,a6+at,0)a6=ab(nil,a6,X)a6=ae(nil,a6,b4)local packetLen=a6-1;local Y=ah(packetLen)a6=a9(Y,1,bI and u or w|2)a6=a5(Y,a6,packetLen)a6=ab(Y,a6,X)a6=a5(Y,a6,at)a6=ai(Y,a6,ar)a6=ae(Y,a6,b4)if bI then a9(Y,a6,bI)end;_(self,X,Y)aU(self,Y)return X end;function bE:subscribe(b4,onsuback,aq,ar)if"table"==type(onsuback)then ar=aq;aq=onsuback;onsuback=nil end;aq=aq or{}ar=L(ar)if aq.onpub then ar.zz_subid=V(self)end;local bF=aq.retainaspublished==true and 8 or 0;local bJ=0~=bF and aq.retainhandling or 0<<4 or 0;local bK=aq.nolocal and 4 or 0;local b5=aq.qos or 0;b5=b5&3;local bI=bJ|bF|bK|b5;local X=bG(self,b4,onsub,ar,bI)self.subackQT[X]={topic=b4,onsuback=onsuback,onpub=aq.onpub,subid=ar.zz_subid}return self.connected end;function bE:unsubscribe(b4,bL,ar)local X=bG(self,b4,bL,ar)self.subackQT[X]={topic=b4,onunsubscribe=bL}return self.connected end;function bE:disconnect(b0)local bM=self.connected;local bN=self.disconnected;self.disconnected=true;if not bN then local Y=ah(2)Y[1]=A;Y[2]=2;Y[3]=b0 or 0;Y[4]=0;aU(self,Y)if self.sock then self.sock:close()end end;self.connected=false;return bM end;function bE:close()pcall(function()self:disconnect()end)end;bE.__gc=bE.close;bE.__close=bE.close;function bE:setwill(an)am(an,3)self.opt.will=an end;function bE:status()return self.sndQElems,self.connected,self.disconnected and true or false end;m=function(self,bz,bO)local function bP()ba.socket.event(bC,self,bz)end;if self.connectTime then local bQ=self.reconTimeout or 5;local bR=ba.clock()//1000-self.connectTime;if bR>0 and bR<bQ then bQ=bQ-bR end;if bQ>0 then ba.timer(bP):set(bQ*1000,true)return end end;if bO then ba.thread.run(bP)else bP()end end;local function bS(self,aq)if not aq.timeout then aq.timeout=5000 end;local aK,aN=ba.socket.connect(self.addr,aq.port or(aq.shark and 8883 or 1883),aq)if not aK then return nil,aN end;if aq.shark and not aq.nocheck then local bT,aW=aK:trusted(addr)if not bT then return nil,aW end end;return aK end;local function bU(addr,bV,b6,aq,ar)if"function"~=type(addr)and"string"~=type(addr)then error(B(1,"string | function",addr),2)end;F(2,"function",bV)if"table"==type(b6)then ar=aq;aq=onsuback;b6=nil end;if b6 then F(3,"function",b6)else b6=function(b4)trace("Received unhandled MQTT topic",b4)end end;aq=aq or{}ar=ar or{}F(4,"table",aq)F(4,"table",ar)aq=L(aq)local self={connected=false,recQosCounter=0,sndQosCounter=0,packetId=0,subscriptionId=0,sndQT={},sndQHead=1,sndQTail=1,sndQElems=0,onstatus=bV,onpub=b6,opt=aq,connect="function"==type(addr)and addr or bS}self.recbta=not(aq.recbta==false)bl(self)if"function"==type(addr)then self.connect=addr else self.connect=bS;self.addr=addr end;if ar then self.prop=L(ar)end;aq.clientidentifier=aq.clientidentifier or ba.b64urlencode(ba.rndbs(15))if aq.keepalive then H("opt.keepalive","number",aq.keepalive)else aq.keepalive=0 end;if aq.secure then if aq.secure==true then aq.shark=ba.sharkclient()else H("opt.secure","userdata",aq.secure)aq.shark=aq.secure end;aq.secure=nil end;m(self,ao(self,true))return setmetatable(self,bE)end;local function bW(...)return require"mqtt3c".connect(...)end;return{create=bU,connect=bW}