local a,b,c,d=string.format,string.char,string.byte,string.sub;local e,f=ba.socket.h2n,ba.socket.n2h;local g=0x01<<4;local h=0x02<<4;local i=0x03<<4;local j=0x08<<4;local k=0x09<<4;local l=0x0a<<4;local m=0x0b<<4;local n=0x0c<<4;local o=0x0d<<4;local p=0x0e<<4;local function q(r,s,t,u)return a("bad argument #%d to '%s' (%s expected, got %s)",r,s,t,type(u))end;local function v(w,x,y,z)if type(y)==x then return end;error(a("%s: expected %s, got %s",w,x,type(y)),z or 3)end;local function A(B)return e(2,#B)..B end;local function C(D)local E={}repeat local F=D%0x80;D=D//0x80;table.insert(E,b(D>0 and F|0x80 or F))until D==0;return table.concat(E)end;local function G(self,H)local I=self.packetId;self.packetIdT[I]=H;self.packetId=I<0xFFFF and I+1 or 1;return e(2,I)end;local function J(self)return self.sock:read()end;local function K(self)local L;if self.recOverflowData then L=self.recOverflowData;self.recOverflowData=nil else L=""end;local M,D,N=1,0,1;repeat N=N+1;while#L<N do local O,P=J(self)if not O then return nil,P end;L=L..O end;local F=c(L,N)D=D+F&0x7F*M;if D>0xFFFF then return nil,"overflow"end;M=M*0x80 until F<0x80;local O=d(L,N+1)while#O<D do local Q,P=J(self)if not Q then return nil,P end;O=O..Q end;local R=c(L,1)&0xF0;if D==#O then return R,O end;assert(#O>D)self.recOverflowData=d(O,D+1)return R,d(O,1,D)end;local function S(self)if self.pingResp then self.error="pingresp"self.sock:close()else self.pingResp=true;self.sock:write(b(n)..b(0))end end;local function T(self,O)local U=f(2,O)self.onpub(d(O,3,U+2),d(O,U+3))return true end;local function V(self,O)local I=f(2,O)local s=self.packetIdT[I]if s then self.packetIdT[I]=nil;s(c(O,3))end;return true end;local function W(self,O)local I=f(2,O)local s=self.packetIdT[I]if s then self.packetIdT[I]=nil;s()end;return true end;local function X(self,O)self.pingResp=nil;return true end;local Y={[i]=T,[k]=V,[m]=W,[o]=X}local Z={}Z.__index=Z;function Z:publish(_,O)O=A(_)..O;return self.sock:write(b(i)..C(#O)..O)end;local function a0(self,_,H,a1)local R=b(a1 and j or l|0x02)local L=G(self,H)..A(_)if a1 then L=L..b(0)end;return self.sock:write(R..C(#L)..L)end;function Z:subscribe(_,H)return a0(self,_,H,true)end;function Z:unsubscribe(_,H)return a0(self,_,H,false)end;function Z:disconnect()self.error="disconnect"local a2,P=self.sock:write(b(p)..b(0))self.sock:close()return a2,P end;function Z:close()pcall(function()self:disconnect()end)end;Z.__gc=Z.close;Z.__close=Z.close;function Z:run()local R,O;while true do R,O=K(self)if not R then break end;local s=Y[R]if not s then return nil,"unknowncp",R end;R,O=s(self,O)if not R then break end end;self.timer:cancel()if not self.error then self.error=O end;return nil,self.error end;local function a3(a4,a5,a6)local self={}a6=a6 or{}if a6.secure and not a6.shark then a6.shark=ba.sharkclient()end;if type(a4)=="string"then local a7,P=ba.socket.connect(a4,a6.port or(a6.shark and 8883 or 1883),a6)if not a7 then return nil,P end;if a6.shark and not a6.nocheck then local a8,a9=a7:trusted(a4)if not a8 then return nil,a9 end end;self.sock=a7 elseif type(a4)=="userdata"and type(a4.trusted)=="function"then self.sock=a4 else error(q(1,"connect","string",a4),2)end;if type(a5)~="function"then error(q(2,"connect","function",a5),2)end;self.pingtmo=a6.keepalive and(a6.keepalive>60 and a6.keepalive or 60)or 10*60;self.id=a6.id or self.sock:sockname()..ba.b64urlencode(ba.rndbs(10))local L=b(0)..b(4).."MQTT"..b(4)local aa=a6.uname and 0x80 or 0|a6.passwd and 0x40 or 0|a6.will and 0x04 or 0|0x02;L=L..b(aa)..e(2,self.pingtmo)..A(self.id)if a6.will then local ab=a6.will;v("opt.will","table",ab)v("opt.will.topic","string",ab.topic)v("opt.will.message","string",ab.message)L=L..A(ab.topic)..A(ab.message)end;if a6.uname then v("opt.uname","string",a6.uname)L=L..A(a6.uname)end;if a6.passwd then v("opt.passwd","string",a6.passwd)L=L..A(a6.passwd)end;self.sock:write(b(g)..C(#L)..L)local R,O=K(self)if not R then return nil,O end;if R~=h then return nil,"invalidresp"end;local ac=c(O,2)if ac~=0 then return nil,ac end;self.packetId,self.packetIdT=1,{}self.onpub=a5;self.timer=ba.timer(function()S(self)return true end)self.timer:set((self.pingtmo-20)*1000)return setmetatable(self,Z)end;return{connect=a3}