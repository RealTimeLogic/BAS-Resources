local a=require"httpc"local function b(c,d)if not c then return d and d or{}end;if not d then return c end;local e={}for f,g in pairs(c)do e[f]=g end;for f,g in pairs(d)do e[f]=g end;return e end;local function h(self)local i=self.raw;if not self.statuscode then local j,k,l,m=i:status()if not j then return nil,k,l,m end;if j==301 or j==302 or j==303 or j==307 then local n=0;local d=self.nop;local o=d.method or"GET"while j==301 or j==302 or j==303 or j==307 do i:read(0)n=n+1;if n==10 then return nil,"redirect"end;local p=i:header"location"if not p then return nil,"invalidresponse"end;local q,r=p:match("([^%?]-)%?(.+)")if q then p=q;d.query=a.parsequery(r)end;if p:match"^https?://"then d.url=p else local s=d.url;s=s:byte(-1)==47 and s:sub(1,-2)or s;d.url=s..p end;if(301==j or 302==j)and("PUT"==o or"POST"==o)then return nil,j,d.url end;d.method=j==307 and o or"GET"local t,k,l,m=i:request(d)if not t then return nil,k,l,m end;j,k,l,m=i:status()if not j then return nil,k,l,m end end end;self.statuscode=j end;return true end;local u={}function u:certificate()return self.raw:certificate()end;function u:cookie()return self.raw:cookie()end;function u:header()return self.raw:header()end;function u:headerpairs()return self.raw:headerpairs()end;function u:timeout(v)return self.raw:timeout(v)end;function u:write(w)return self.raw:write(w)end;function u:read(x)local t,k,l,m=h(self)if t then return self.raw:read(x)end;return nil,k,l,m end;function u:cipher()return self.raw:cipher()end;function u:trusted()return self.raw:trusted()end;function u:sockname()return self.raw:sockname()end;function u:peername()return self.raw:peername()end;function u:status(x)local t,k,l,m=h(self)if t then return self.statuscode end;return nil,k,l,m end;function u:close()h(self)return self.raw:close()end;function u:request(d)self.statuscode=nil;local y=self.op;y.query=nil;self.nop=b(y,d)return self.raw:request(self.nop)end;function u:url()if not self.statuscode then local t,k,l,m=h(self)if not t then return nil,k,l,m end end;return self.nop.url,self.nop.query end;function u:mkop(z,A)return A and b(z,A)or b(self.op,z)end;local B={}function B.create(d)d=d and b({},d)or{}local C={raw=a.create(d)}local D={"shark","persistent","intf","ipv6","proxy","proxyport","socks","proxyuser","proxypass"}for E,g in ipairs(D)do d[g]=nil end;C.op=d;C.nop=d;return setmetatable(C,{__index=u})end;function B.getmetatable()return u end;return B